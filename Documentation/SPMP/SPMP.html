<html>
<head><link rel="stylesheet" href="SPMP.css">
</style></head><body>
    <header>
        <center>
            <h1>
                Team Rocket
            </h1>
            SPMP
            <br>Version 0.1 - 1/21/2021
        </center>
	</header>
	<h2>Table of contents</h2>
    <ul>
        <li><a href="#1.0.0">Introduction</a>
        <ul>
            <li><a href="#1.1.1">Purpose</a></li>
            <li><a href="#1.1.2">Scope</a></li>
			<li><a href="#1.1.3">Assumptions and Constraints</a>
			<li><a href="#1.1.4">Evolution of the Plan</a>
		</ul></li>

        <li><a href="#2.0.0">References</a>
        
		<li><a href="#3.0.0">Definitions</a>
			
		<li><a href="#4.0.0">Project Organization</a></li>
		<ul>
			<li><a href="#4.1.0">Product Perspective</a></li>
			<li><a href="#4.2.0">Organization Structure</a></li>
			<li><a href="#4.3.0">Project Responsibilities</a></li>
		</ul>
		<li><a href="#5.0.0">Managerial process plans</a></li>
		<ul>
			<li><a href="#5.1.0">Project start-up plan</a></li>
			<li><a href="#5.1.2">Staffing plan</a></li>
			<li><a href="#5.1.3">Project staff training plan</a></li>
			<li><a href="#5.2.0">Work plan</a></li>
			<li><a href="#5.2.1">Work activities</a></li>
			<li><a href="#5.2.2">Schedule allocation</a></li>
			<li><a href="#5.2.3">Resource allocation</a></li>
			<li><a href="#5.3.0">Control plan</a></li>
			<li><a href="#5.3.1">Requirements control plan</a></li>
			<li><a href="#5.3.2">Schedule control plan</a></li>
			<li><a href="#5.3.3">Quality control plan</a></li>
		</ul>
		<li><a href="#6.0.0">Managerial process plans</a></li>
		<ul>
			<li><a href="#6.1.0">Process model</a></li>
			<li><a href="#6.2.0">Methods, tools, and techniques</a></li>
		</ul>
		<li><a href="#7.0.0">Supporting process plans</a></li>
		<ul>
			<li><a href="#7.1.0">Verification and validation plan</a></li>
			<li><a href="#7.2.0">Documentation plan</a></li>
			<li><a href="#7.3.0">Quality assurance plan</a></li>
		</ul>
		<li><a href="#8.0.0">Additional plans</a></li>
		<ul>
			<li><a href="#8.1.0">Plan index</a></li>
		</ul>
		<li><a href="#9.0.0">Version</a></li>
		<li><a href="#10.0.0">Authors</a></li>
	</ul>
	<br>
	
	<h2><span id="1.0.0">(1.0.0) Introduction</span></h2>

	<p>The Pokédex Encyclopedia(“the project”, “the software”) is a third party database created for the access of information on Generation I Pokémon. The purpose of this application is to give Pokémon players access to a greater depth of information on Pokémon that is not provided by the in-game Pokédex. This encyclopedia will be a guide for players who aims for completion rather than the be all and end all. Vital information like base stats, in-game locations, type effectiveness, natures, and learnset is not provided by other online encyclopedias. The Pokédex Encyclopedia strives to provide this information to allow the players to make educated decisions on how they would like to play the game. </p>
	
	<h3><span id="1.1.1">(1.1.1) Purpose</span></h3>

	<p>
		The purpose of this project is to provide Pokémon players with a comprehensive database of relevant information to allow them to make educated decisions on how they would like to play the game. Specifically, how they can optimize their Pokémon teams based on information our application provides. 
	</p>
	
	<h3><span id="1.1.2">(1.1.2) Scope</span></h3>

	<p>
		We aim to have all 151 Generation I Pokémon in our database, along with the following information which has already been provided by the ingame Pokédex: name, description, type(s), height, weight, brief biography description. As well as additional information that is relevant but not provided in-game: abilities, catch rate, type match ups, leveling-rate, EV yield. As well, we would like to have a user account system using a password hashing algorithm to store passwords. Users will be able to save information to their account. 
	</p>

	<h3><span id="1.1.3">(1.1.3) Assumptions and Constraints</span></h3>
	<p>
		The biggest constraint on this project will be time. We have a set timeline to accomplish the objectives we have declared. Furthermore, our understanding of the software we have available to us may be another limitation. It's possible that members will have to learn how to use this software before being able to implement the objectives. Another constraint is acquiring Pokémon data. We will need to find a source with all this information, otherwise entering this information in manually will be repetitive.
	</p>

		
	<h3><span id="1.1.4">(1.1.4) Evolution of the Plan</span></h3>
	<p>
		This section will be updated as we progress through the project.
	</p>

	<h2><span id="2.0.0">(2.0.0) References</span></h2>
	<ul>
		<li>IEEE. IEEE Std 830-1998 IEEE Recommended Practice for Software Requirements Specifications. IEEE Computer Society, 1998<br><a href="http://partyall-docs.herokuapp.com/docs/partyall-software-requirements.html">http://partyall-docs.herokuapp.com/docs/partyall-software-requirements.html</a> </li>
		<br>
		<li>Software Project Management Plan (SPMP)<br> <a href="https://cs.uwaterloo.ca/~apidduck/se362/Assignments/A2/spmp">https://cs.uwaterloo.ca/~apidduck/se362/Assignments/A2/spmp</a></li>
	</ul>

	<h2><span id="3.0.0">(3.0.0) Definitions</span></h2>

	<u><b>Move</b></u>: A move, also known as an attack is the skill Pokémon primarily use in battle.
	<br>
	<br>
	<u><b>Type</b></u>: Pokémon and the different moves they can use are all classified by properties called Types. A Pokémon can be associated with one or two types whereas a move can only be associated with one type. Moves that deal damage to other Pokémon can have more of an effect, a neutral level of effectiveness, less of an effect, or no effect at all, based on their type and the type of the Pokémon they are being used against. An example of an effective move would be a Pokémon using a Fire type move against a Grass type Pokémon. An example of a less effective move would be a Pokémon using a Fire type move against a Water type Pokémon. Finally, an example of a move which would have no effect at all would be a Ghost type move being used against a Normal type Pokémon.
	<br>
	<br>
	<u><b>Abilities</b></u>: An Ability is a game mechanic that provides a passive effect in battle or in the overworld. Individual Pokémon may have only one Ability at a time. Not every Ability is entirely beneficial; some of them are hindering.
	<br>
	<br>
	<u><b>Catch rate</b></u>: Each species of Pokémon has a catch rate that applies to all its members. When a Poké Ball is thrown at a wild Pokémon, the game uses that Pokémon's catch rate in a formula to determine the chances of catching that Pokémon. Higher catch rates mean that the Pokémon is easier to catch, up to a maximum of 255.
	<br>
	<br>
	<u><b>Type matchup chart</b></u>: A type chart, also known as type matchup chart, shows which modifiers are applied to move types when attacking Pokémon of each type. 
	<br>
	<br>
	<u><b>EV yield</b></u>: When a Pokémon is defeated in battle, it will give effort values to the Pokémon that participated in the battle against it. 
	

	<h2><span id="4.0.0">(4.0.0) Project Organization</span></h2>
	<h3><span id="4.1.0">(4.1.0) Product Perspective</span></h3>
	<P>
		There will be two major components to this application, front-end and back-end.<br><br>
		Front-end will deal with the user experience/interface. The goal is to create a GUI that is pleasant and easy to use. The GUI will be appealing; images of the Pokémon will be included as well as having the text information placed appropriately. Ideally we would like to have a search function that will be able to communicate with the backend.<br><br>
		Back-end will deal with the information stored in the database. The goal will be to create a comprehensive database with all the information that we would like to have for each Pokémon object. The objects in this database will remain static; unless we make plans to add further generations of Pokémon to this project, we will not have features to add new Pokémon. Clean information retrieval is key to this project. <br>
	</P>

	<h3><span id="4.2.0">(4.2.0) Organization Structure</span></h3>
	<p>To accomplish all the project requirements, we will divide ourselves into groups and each group will be responsible for completing certain tasks. One person from the group will be responsible for communicating with the rest of the team and making their work available for the rest of the team. There will be a testing team who will work on testing the implementation and assure that the application will be able to work properly for any possible case. The members who were a part of implementation will not be a part of the testing team. </p>

	<h3><span id="4.3.0">(4.3.0) Project Responsibilities</span></h3>
	<table id="Responsibilities">
		<tr>
			<th id="first">Deliverables</th>
			<th id="first">Group Members</th>
		</tr>
		<tr>
			<th>Requirements document</th>
			<th>Everyone</th>
		</tr>
		<tr>
			<th>Software Project Management Plan (SPMP)</th>
			<th>Priya, Carson (William)</th>
		</tr>
		<tr>
			<th>Object-oriented analysis</th>
			<th>Alina, Sunil, Kevin He, Lingjie(Jessica), Graeme</th>
		</tr>
		<tr>
			<th>Design</th>
			<th>Ian, Prit, Alina, Graeme, Lingjie(Jessica), Dhavani</th>
		</tr>
		<tr>
			<th>Prototype</th>
			<th>Priya, Sunil, Dhavani, Prit, Michelle Muliana, Jimmy</th>
		</tr>
		<tr>
			<th>Front-end</th>
			<th>Ian, Prit, Louise, Kevin He, Jimmy, Michelle Muliana, Andrei</th>
		</tr>
		<tr>
			<th>Back-end</th>
			<th>Scott, Andrei, Sunil, Alina, Louise, Aozhou</th>
		</tr>
		<tr>
			<th>Testing</th>
			<th>Everyone not involved in the implementation </th>
		</tr>
	</table>

	<h2><span id="5.0.0">(5.0.0) Managerial process plans</span></h2>

	<h3><span id="5.1.0">(5.1.0) Project start-up plan</span></h3>
	<h3><span id="5.1.2">(5.1.2) Staffing plan</span></h3>
	<p>
		For this project, we are working with a team of 16 members. We plan on dividing ourselves into smaller groups based on skill level and interest to work on different aspects of the project such as design, prototyping and implementation. There are two documentation, Requirement Document and SPMP that need to be worked on and updated as we go.<br><br>

		A small group of the team members who are interested in preparing the documentation will be responsible for the documentation. At least one of the members should be experienced with HTML and take the responsibility of creating the document through HTML. As per the analysis and design, both must be object-oriented and so the team members working on these should have a fair amount of knowledge on object-orientated programming or are willing to learn it in the given time frame.<br><br> 

		For prototyping, a small group of the team members will be responsible for designing the looks for this application and creating options for how the users can interact with the application. At least one person should be familiar with UX design and Figma, overall, everyone should be willing to learn about the UI development process and work with a creative mind set. For front and back end, the members responsible should be experienced with the languages being used (mentioned below in section 6.2). They should also be willing to put in sometime to learn new material that may be required for the implementation. The testing crew will be members of the team that have not worked on the implementation. They should be able to consider all possible cases that might occur when other users start using the application and make sure the application is capable of handling the cases.

	</p>
	<h3><span id="5.1.3">(5.1.3) Project staff training plan</span></h3>
	<p>
		A basic understanding of some software will be required for the completion of this project. Each group member will be responsible for learning any new material/software that is required to complete the deliverables they have chosen.
	</p>

	<h2><span id="5.2.0">(5.2.0) Work plan</span></h2>
	<h3><span id="5.2.1">(5.2.1) Work activities</span></h3>
	<table id="Work-plan">
		<tr>
			<th id="first">
				<p><b>Deliverable 1: Requirements Document</b></p>
			</th>

			<th id="first">
				<p><b>Deliverable 2: Software Project Management Plan</b></p>
			</th>

			<th id="first">
				<p><b>Deliverable 3: Object Oriented analysis </b></p>
			</th>
			<th id="first">
				<p><b>Deliverable 4: Design</b></p>
			</th>
			<th id="first">
				<p><b>Deliverable 5: Prototype </b></p>
			</th>
			<th id="first">
				<p><b>Deliverable 6: Front-end </b></p>
			</th>
			<th id="first">
				<p><b>Deliverable 7: Back-end </b></p>
			</th>
			<th id="first">
				<p><b>Deliverable 8: Testing</b></p>
			</th>
			
		</tr>

		<tr>
			<th>
				<ol type="1">
					<li>Discuss the specifications of the application</li>
					<li>Finalize the requirements for the project</li>
					<li>Write out a document for requirements</li>
					<li>Transfer the document into HTML </li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Read through the IEEE documentation and figure out what to include for our SPMP</li>
					<li>Organize the clauses on a document and discuss each one as a team</li>
					<li>Write out the details for each clause</li>
					<li>Transfer the document to HTML</li>
					<li>Update the document as we go along</li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Display, list, and define the entity/boundary/control objects required.</li>
					<li>Record the relationships between the different classes (each associated should have a name, role, and multiplicity).</li>
					<li>Identify class attributes and assign a type to each.</li>
					<li>Review model for completeness, correctness, and consistency.</li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Determine a list of design goals.</li>
					<li>Decompose the project into the subsystems and define broad details and the responsibilities of each.</li>
					<li>Determine in which subsystem the entity classes belong to.</li>
					<li>Decide the control flow.</li>
					<li>Decide the access control.</li>
					<li>Decide the data storage (e.g. how the entities map to SQL tables).</li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Discuss and brainstorm creative ideas for an GUI</li>
					<li>Short list some of the team's favourite Idea’s</li>
					<li>Using Figma, design each idea in different files </li>
					<li>Have someone who was not a part of prototyping use it and get their opinions on it. Ask them questions like: which design is your favorite? What is something you might want to change? What is the best part of this design? What can we add or remove to make it interesting and easier for the user to use?</li>
					<li>Based on the answers to the above questions, change up the design(minor changes) to make it better.</li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Take a look at the prototype and use it to understand the design of the GUI</li>
					<li>Based on the prototype, figure out what is necessary for implementing it.</li>
					<li>Set subtasks for the program</li>
					<li>Code the implementation step-by-step</li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Go over the requirements or the application. Understand what the application has to accomplish.</li>
					<li>Based on the requirements, create a plan for implementation and break it down into steps</li>
					<li>Start coding the implementation</li>
				</ol>
			</th>

			<th>
				<ol type="1">
					<li>Start by running the application and using it in various ways to get a feel for how the application works</li>
					<li>Make a list of all possible scenarios that could happen when a user is using the application</li>
					<li>Start by testing the scenarios that may lead to errors or the application crashing to see if the program is able to handle such cases</li>
					<li>Let the implementation team know of any cases the program isn’t able to handle and give them some time to make the changes</li>
					<li>Test for the error cases again to ensure everything works</li>
					<li>Test the program for each of its requirements, for example, does the program do what it is supposed to when you click on a certain button?</li>
					<li>Let the implementation team know if any of the requirements are not fulfilled or if something doesn’t work as described. Give them some time to work these things through</li>
					<li>Test again for errors and requirements to assure everything is working as expected</li>
				</ol>
			</th>


		</tr>
	</table>
	
	<h3><span id="5.2.2">(5.2.2) Schedule allocation</span></h3>
	<p>
		The schedule path that this project will follow will be in accordance with the course syllabus schedule. Phases will be completed in a timely manner to allow for the development of this project. The phases include:
		<ul>
			<li>Group Sign-Up (completed)</li>
			<li>Specifications</li>
			<li>Software Project Management Plan</li>
			<li>Requirements</li>
			<li>Analysis</li>
			<li>Design</li>
			<li>implementation/User Documentation</li>
		</ul>
		
	</p>
	<h3><span id="5.2.3">(5.2.3) Resource allocation</span></h3>
	<p>
		The specifications in resource allocation have to deal with more physical aspects of the project, which are universally available to all group members. The only topic that is relevant to this group is the required skill level of personnel. Group members will assign themselves to the topics that they feel comfortable contributing to. This will ensure that the work is distributed amongst the group so that everyone contributes in some way to this project regardless of skill. Group members work on different aspects of the project concurrently. Milestones will be the deliverables mentioned above, 
	</p>

	<h2><span id="5.3.0">(5.3.0) Control plan</span></h2>
	<h3><span id="5.3.1">(5.3.1) Requirements control plan</span></h3>
	<p>
		As we go along with the process of developing the application, requirements may change. There will be a few steps to take before any changes are made. First we have to consider how the change will impact the product and will it be impacted positively or negatively? The next step is to think about how many changes will be needed based on the new requirements, how large are these changes and do we have enough time to implement these changes? Lastly, are we capable of implementing such changes based on our skill level. Once these questions are answered, as a team we will decide if we should go forward with the change or not. 
	</p>

	<h3><span id="5.3.2">(5.3.2) Schedule control plan</span></h3>
	<p>
		In order to deliver the project on time, we will be maintaining our progress and will have a potential time frame for each task. For each task, we will decide on an approximate deadline which will be ahead of the actual due date. Within the main tasks we will create subtasks and will have a due date for each subtask. Along with the due date, we will have a due date two for each sub task as well which will be the final deadline for that subtask. The first due date will not be a hard due date. 
	</p>
	<h3><span id="5.3.3">(5.3.3) Quality control plan</span></h3>
	<p>
		To ensure that we deliver a quality project we will be spending a fair amount of time testing each individual feature as it is developed. The whole team will have the responsibility of looking for bugs in the code, reporting the bugs, and working together to eliminate these bugs. To keep track of the bugs there will be a bug tracking spreadsheet where each bug will be reported, where to find the bug in the code, the importance of the bug being fixed, and how to reproduce the bug.
	</p>

	<h2><span id="6.0.0">(6.0.0) Technical process plans</span></h2>
	<h3><span id="6.1.0">(6.1.0) Process model</span></h3>
	<p><b>TBA</b></p>
	<h3><span id="6.2.0">(6.2.0) Methods, tools, and techniques</span></h3>
	<ul style="list-style-type:none;">
		<li><b>Languages: </b>HTML, Python, SQL</li>
		<li><b>Version Control: </b>Git</li>
		<li><b>Prototyping Software: </b>Figma</li>
		<li><b>Project Management: </b>GitHub, Sheets, Discord</li>
	</ul>
	
	<h2><span id="7.0.0">(7.0.0) Supporting process plans</span></h2>
	<h3><span id="7.1.0">(7.1.0) Verification and validation plan</span></h3>
	<p>
		Verification and validation is an important step for any project to go to a stable state. A stable state is when a program has been tested and validated as bug free. This state is where it has successfully completed specific requirements for the project. <br><br>

		Throughout the project, the team will test for bugs as developers work. All bugs will be reported to the bug tracking system with a report on where the bug is located and replication of the bug. When the project finishes their tasks for the current version (of project), it will then proceed to the verification and validation phase. <br><br>

		Our verification and validation plan is a process of steps.
	</p>
	<ol type="1">
		<li>Complete the current requirements for the current version of the software.</li>
		<li>Members from front-end and back-end will verify the completion of the current version.</li>
		<li>Make an announcement to the group members that the software is completed for testing.</li>
		<li>Group members will test the software from the front-end and report bugs, and present a report on how to replicate it.</li>
		<li>Group members will analyze the back-end code for any missing documentation and mark down for fix.</li>
		<li>Developers will fix any major software-breaking bugs.</li>
		<li>Front-end and back-end developers will have a quick meeting to agree on finalizing the current version of the software.</li>
		<li>Once finalized and validated, developers will set the current version as a stable version.</li>
	</ol>

	<h3><span id="7.2.0">(7.2.0) Documentation plan</span></h3>
	<p>
		Documentation is an important process when handling code. It is important when it comes to coding as it gives a short and concise description of what the code does. This is beneficial for other developers when they use another developer’s code. Documentation not only benefits you as a developer, but your peers, and future developers of the project. <br><br>

		Our plan for documenting our project, we agreed that we have requirements when documenting. Bellow are the requirements when documenting any code
	</p>
	<ul>
		<li>Name of author of the function/class/etc.</li>
		<li>Date of creation by the author of the function/class/etc.</li>
		<li>Description of what the function/class/etc. does</li>
		<li>List any used parameters/returns and put a description of their usage and variable types</li>
		<li>Name of editor who last modified code</li>
		<li>Date of edit by the editor who last modified code</li>
	</ul>
	<h3><span id="7.3.0">(7.3.0) Quality assurance plan</span></h3>
	<p>
		Quality assurance is key to creating a quality final product. In order to succeed in that we have a plan to ensure that we create the best Pokédex Encyclopedia we can. The most important  step in this process is making sure each member of the group looks at and approves of each stage in this project. That means proper coding practices and style, good informative documentation as well as general software development practices. Each member should have a good grasp of most of the basic level parts of this project and be able to identify where the project should be improved or changed. A practice that will help us achieve this is having each member look over the particular part of this project that is due and coming to meetings with constructive criticism to help improve the overall quality of the project. As a final step that should be standard is that everyone will test the various aspects of the project. This will help catch any obscure errors or bugs that might not have been caught by the programmer who wrote the code in the first place. The combination of all of these processes will help develop a high quality final product.
	</p>

	<h2><span id="8.0.0">(8.0.0) Additional plans</span></h2>
	<h3><span id="8.1.0">(8.1.0) Plan index</span></h3>
	<p>
		<b>Generation I Pokémon</b> - the first generation of Pokémon featuring the original 151 species of Pokémon.<br><br>

		<b>Pokédex</b> - a device which is designed to catalogue and provide information about various different species of Generation I Pokémon.<br><br>

		<b>The Pokédex Encyclopedia</b> - a third party database created for the access of information on Generation I Pokémon.<br><br>

		<b>Catch Rate</b> - the initial calculation which in Pokémon , determines the probability of catching a Pokémon.<br><br>
	</p>



	
	<h2><span id="9.0.0">(9.0.0) Versions</span></h2>
	<h5>Version 0.1 - 1/21/2021</h5>
	<i>Document created</i>
	<br>
	<h5>Version 0.2 - 2/05/2021</h5>
	<i>Updated deliverables & Team roles</i>

	<!-- This is for future edits, leave it alone for now-->
	<!-- <h5>Version 1.0 - *insert date*</h5>
	<i>Sections modified and expanded</i>
		<ul>
		</ul> -->


	<h2><span id="10.0.0">(10.0.0) Authored By</span></h2>
	<ul>
		<li>Sunil Brijlall</li>
		<li>William Bunker</li>
		<li>Lingjie Chen</li>
		<li>Aozhou Hao</li>
		<li>Kevin He</li>
		<li>Graeme Kempf</li>
		<li>Michelle Muliana</li>
		<li>Andrei Pana</li>
		<li>Prit Patel</li>
		<li>Dhavani Patel</li>
		<li>Alina Penskaya</li>
		<li>Louise Peralta</li>
		<li>Ian Roberts</li>
		<li>Priya Shukla</li>
		<li>Scott Vodon</li>
		<li>Jinyuan Wang</li>
	</ul>
</body></html>